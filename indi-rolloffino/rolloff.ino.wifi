/*
 * A controller example for roof motor controller from the INDI rolloffino roof driver.
 *
 * tg August 2018  Original
 *
 * tg February 2020 Generalize to make less installation specific
 *                  Add unspecified usage AUX switch and relay
 *                  Communication protocol in terms of function not switches/relays
 *                  ~ 15KB 2% of Due, 50% of Nano
 *
 * tg November 2021 Break out commandReceived and requestReceived to make alternate
 *                  actions more obvious/accessible, Remove Due specific code.
 *
 * tg January 2022  Add this example of using WiFi between the Arduino and the INDI
 *                  rolloffino roof driver
 *
 * tg May 2025      Updated to use Uno R4 WiFi and add support for Actions. Indicate
 *                  to the driver during handshake if Actions are supported and the driver
 *                  can issue them. The driver needs to be 2.1.3 or later
 */

/*
 * This WiFi version of the rolloff.ino is for use with a "Arduino Uno R4 WIFI" using
 * the WiFiS3 library. It is initialized for a network using WPA encryption.
 * The file arduino_secrets.h found in the same directory as this rolloff.ino code is to
 * be used to specify the network SSID and password that the Arduino should use.
 *
 * When using WiFi the serial monitor can be used for diagnostic messaging in the IDE,
 * if the USB is also connected between the Arduino and the host.
 * If there is difficulty getting the INDI roof driver to connect, need to establish that the
 * WiFi network is working and that the Arduino is connected. Running the Arduino IDE and
 * using its serial monitor can be helpful to see any diagnostic messages.
 * INIT_DELAY_SECS can be defined to wait a number of seconds after starting the Arduino
 * to have time to get the serial monitor display started and see network startup messages.
 */

#define INIT_DELAY_SECS 2

#include <SPI.h>
#include <WiFiS3.h>
#include "arduino_secrets.h"

/*
 * The driver can support up to 8 extra actions. The Arduino sketch indicates it can accept
 * actions and how many during the initial connection request from the driver.
 * Return version_id like "V1.3" which indicates the extra actions not supported.
 * Return version_id like "V1.3 [ACT2]" if two extra actions are supported.
 *
 * Additional actions will typically be used to set extra relays. But this depends on the
 * Arduino implementation. Only indicate support for the number of additional actions the
 * sketch can recognise and support. For each additional action the Arduino requests, it needs
 * to be prepared to accept a corresponding request for completion status.
 *
 * Can use the extra actions but does not predefine or request them. This sketch is compatible with using a
 * gate opener controller and the Arduino.cc relay shield without needing any code edits. Default roof
 * open/close directed to a relay shield or to a four channel relay module wired to those same
 * pins. The example rolloff.ino.relay-action is similar but does request the driver send Actions and
 * includes a couple of Action examples using a relay shield plus a four channel relay module.
 */

//////////////////////////////////////////////////////////
// Start of Definitions
//////////////////////////////////////////////////////////

#define VERSION_ID "V1.3"  // Action relays not connected
//#define VERSION_ID "V1.3 [ACT2]"  // Action relay driver support enable

//////////////////////////////////////////////////////////
// Input sensor definitions
//////////////////////////////////////////////////////////

// Input Switch definition, indicates when input sensor switch is open the voltage on the pin will be
// HIGH indicating off. Changing to LOW requires installation of external pull-down resistors.
#define OPEN_CONTACT HIGH

// Define input sensor switch name to pin assignment
#define SWITCH_1 A0
#define SWITCH_2 A1
#define SWITCH_3 A2
#define SWITCH_4 A3
#define SWITCH_5 A4
#define SWITCH_6 A5

// For the normal roof position switches
// Indirection to define a functional state in terms of an input switch or sensor
// Use 0 if a sensor or switch is not provided.
#define SWITCH_OPENED SWITCH_1  // Fully opened is assigned to switch 1
#define SWITCH_CLOSED SWITCH_2  // Fully closed is assigned to switch 2
#define SWITCH_LOCKED SWITCH_3  // External lock
#define SWITCH_AUX SWITCH_4     // Auxiliary switch
#define ACT1STATE 0
#define ACT2STATE 0
#define ACT3STATE 0
#define ACT4STATE 0
#define ACT5STATE 0
#define ACT6STATE 0
#define ACT7STATE 0
#define ACT8STATE 0

//////////////////////////////////////////////////////////
// Command definitions
//////////////////////////////////////////////////////////

// Define output relays, name to pin assignments. The first 4 definitions match the
// Arduino.cc standard Uno relay shield
#define RELAY_1 4
#define RELAY_2 7
#define RELAY_3 8
#define RELAY_4 12
#define RELAY_5 5
#define RELAY_6 6
#define RELAY_7 9
#define RELAY_8 10

// Indirection to define a functional name in terms of a relay
// There are 5 functions here, by default only 4 relays are allocated. Some
// functions might map to the same relay. If open, close and stop all require
// their own relay, then choose between use of AUX or LOCK. Or extend the relay definitions.
// Use 0 if function not supported.  Set to 100 if there is special code added to handle it.
#define FUNC_OPEN RELAY_1
#define FUNC_CLOSE RELAY_1  // For a single button controller might map this also to RELAY_1
#define FUNC_ABORT RELAY_1  // For a single button controller might map this also to RELAY_1
#define FUNC_LOCK 0         // If automated roof lock is available.
#define FUNC_AUX 0          // Relay to perform some unspecified function

// Define the additional functions as action relays
// Use 0 if function not supported.  Set to 100 if there is special code added to handle it.
#define FUNC_ACT1 0 // Actions specify relay for Action 1 example: "#define FUNC_ACT1 RELAY 5" 
#define FUNC_ACT2 0
#define FUNC_ACT3 0
#define FUNC_ACT4 0
#define FUNC_ACT5 0
#define FUNC_ACT6 0
#define FUNC_ACT7 0
#define FUNC_ACT8 0

//
// For the relay that a function is mapped to, indicate if that relay is to be momentarily closed
// or held in a closed position. If for example the relay is intended to provide power to a motor
// the need might be to keep it closed until a relay off is received. If a function such as OPEN
// is held on, it will be up to local code in the Arduino to determne when and how to turn it off.
// The host driver sends open and close requests but expects the roof to brings itself to a stop
// when complete.
//
// If HOLD is 0 then the relay will be activated for RELAY_DELAY milliseconds, then released.
// If the relay is simulating a button push/release to the motor controller HOLD would be 0.
//
#define FUNC_OPEN_HOLD 0
#define FUNC_CLOSE_HOLD 0
#define FUNC_ABORT_HOLD 0
#define FUNC_LOCK_HOLD 1
#define FUNC_AUX_HOLD 1
#define FUNC_ACT1_HOLD 1
#define FUNC_ACT2_HOLD 1
#define FUNC_ACT3_HOLD 1
#define FUNC_ACT4_HOLD 1
#define FUNC_ACT5_HOLD 1
#define FUNC_ACT6_HOLD 1
#define FUNC_ACT7_HOLD 1
#define FUNC_ACT8_HOLD 1

// Active polarity per function
#define FUNC_OPEN_ACTIVE HIGH
#define FUNC_CLOSE_ACTIVE HIGH
#define FUNC_ABORT_ACTIVE HIGH
#define FUNC_LOCK_ACTIVE HIGH
#define FUNC_AUX_ACTIVE HIGH
#define FUNC_ACT1_ACTIVE LOW
#define FUNC_ACT2_ACTIVE LOW
#define FUNC_ACT3_ACTIVE LOW
#define FUNC_ACT4_ACTIVE LOW
#define FUNC_ACT5_ACTIVE LOW
#define FUNC_ACT6_ACTIVE LOW
#define FUNC_ACT7_ACTIVE LOW
#define FUNC_ACT8_ACTIVE LOW

// Timing
#define RELAY_PRIOR_DELAY 50
#define RELAY_ON_DELAY 500
#define RELAY_POST_DELAY 50

/*
 * Abort (stop) request is only meaningful if roof is in motion.
 * On Abort for a single button controller, only want to activate relay and pulse the 
 * controller if the roof is still moving, then it would stop. If it has already stopped 
 * a pulse could set it off again in the opposite direction.
 * In case the end of run switches are not reached, some way to know if it is moving
 * would be helpful. Short of that estimate how long it takes the roof to open or close
 * This makes the use of abort problematic. Could add something like an encoder in the
 * install to check if the roof is still moving. Otherwise try to avoid using the abort.
 */
#define ABORT_MAX_SEC 30
#define BAUD_RATE 9600 // 38400
#define INTERNET_ADDR 192,168,1,227   // Address being used by Arduino, match in INDI driver tab
#define INTERNET_PORT 23              // Listen on telnet port, match in INDI driver tab
                                      // Sensitive data is defined in 'arduino_secrets.h'


//////////////////////////////////////////////////////////
// End of Definitions
//////////////////////////////////////////////////////////

struct switch_control {
  const char* function;
  unsigned int source;
};

const int switch_count = 12;
switch_control switch_info[switch_count] = {
  { "OPENED", SWITCH_OPENED },
  { "CLOSED", SWITCH_CLOSED },
  { "LOCKED", SWITCH_LOCKED },
  { "AUXSTATE", SWITCH_AUX },
  { "ACT1STATE", ACT1STATE },
  { "ACT2STATE", ACT2STATE },
  { "ACT3STATE", ACT3STATE },
  { "ACT4STATE", ACT4STATE },
  { "ACT5STATE", ACT5STATE },
  { "ACT6STATE", ACT6STATE },
  { "ACT7STATE", ACT7STATE },
  { "ACT8STATE", ACT8STATE }
};

enum cmd_input {
  CMD_NONE,
  CMD_OPEN,
  CMD_CLOSE,
  CMD_ABORT,
  CMD_LOCK,
  CMD_AUXSET,
  CMD_ACT1SET,
  CMD_ACT2SET,
  CMD_ACT3SET,
  CMD_ACT4SET,
  CMD_ACT5SET,
  CMD_ACT6SET,
  CMD_ACT7SET,
  CMD_ACT8SET
} command_input;
const int cmd_len = CMD_ACT8SET + 1;

struct relay_control {
  cmd_input cmd;
  const char* function;
  unsigned int relay;
  unsigned int hold;
  unsigned int activate;
};

relay_control relay_info[cmd_len] = {
  { CMD_NONE, "None", 0, 0, FUNC_OPEN_ACTIVE },
  { CMD_OPEN, "OPEN", FUNC_OPEN, FUNC_OPEN_HOLD, FUNC_OPEN_ACTIVE },
  { CMD_CLOSE, "CLOSE", FUNC_CLOSE, FUNC_CLOSE_HOLD, FUNC_CLOSE_ACTIVE },
  { CMD_ABORT, "ABORT", FUNC_ABORT, FUNC_ABORT_HOLD, FUNC_ABORT_ACTIVE },
  { CMD_LOCK, "LOCK", FUNC_LOCK, FUNC_LOCK_HOLD, FUNC_LOCK_ACTIVE },
  { CMD_AUXSET, "AUXSET", FUNC_AUX, FUNC_AUX_HOLD, FUNC_AUX_ACTIVE },
  { CMD_ACT1SET, "ACT1SET", FUNC_ACT1, FUNC_ACT1_HOLD, FUNC_ACT1_ACTIVE },
  { CMD_ACT2SET, "ACT2SET", FUNC_ACT2, FUNC_ACT2_HOLD, FUNC_ACT2_ACTIVE },
  { CMD_ACT3SET, "ACT3SET", FUNC_ACT3, FUNC_ACT3_HOLD, FUNC_ACT3_ACTIVE },
  { CMD_ACT4SET, "ACT4SET", FUNC_ACT4, FUNC_ACT4_HOLD, FUNC_ACT4_ACTIVE },
  { CMD_ACT5SET, "ACT5SET", FUNC_ACT5, FUNC_ACT5_HOLD, FUNC_ACT5_ACTIVE },
  { CMD_ACT6SET, "ACT6SET", FUNC_ACT6, FUNC_ACT6_HOLD, FUNC_ACT6_ACTIVE },
  { CMD_ACT7SET, "ACT7SET", FUNC_ACT7, FUNC_ACT7_HOLD, FUNC_ACT7_ACTIVE },
  { CMD_ACT8SET, "ACT8SET", FUNC_ACT8, FUNC_ACT8_HOLD, FUNC_ACT8_ACTIVE }
};

//  Maximum length of messages = 63                                               *|
const char* ERROR1 = "The controller response message was too long";
const char* ERROR2 = "The controller failure message was too long";
const char* ERROR3 = "Command input request is too long";
const char* ERROR4 = "Invalid command syntax, both start or end token missing";
const char* ERROR5 = "Invalid command syntax, no start token found";
const char* ERROR6 = "Invalid command syntax, no end token found";
const char* ERROR7 = "Roof controller unable to parse command";
const char* ERROR8 = "Command must map to either set a relay or get a switch";
const char* ERROR9 = "Request not implemented in controller";
const char* ERROR10 = "Abort ignored, roof already stationary, or time expired";
const char* ERROR11 = "Unknown input, ";
const char* ERROR12 = "Action directive incompatible with current state ";
const char* ERROR13 = "Unable to read input";

char ssid[] = SECRET_SSID;         // your network SSID (name)
char pass[] = SECRET_PASS;         // your network password (use for WPA, or use as key for WEP)
int keyIndex = 0;                  // your network key index number (needed only for WEP)
IPAddress ip(INTERNET_ADDR);       // Arduino's local Internet address. Defined above
WiFiServer server(INTERNET_PORT);  // Arduino server listening for connections on port specified
WiFiClient client;                 // Connection to communicate with the indi driver

// Buffer limits must match those in the driver
#define MAX_INPUT 45
#define MAX_RESPONSE 127
#define MAX_MESSAGE 63

const char* version_id = VERSION_ID;

const int cLen = 15;
const int tLen = 15;
const int vLen = MAX_RESPONSE;
char command[cLen + 1];
char target[tLen + 1];
char value[vLen + 1];

// Movement timing for abort window
int32_t timeMoveMs = 0;

// Test:
boolean diag = true; 
int64_t tstart = 0;    // Start time testing timeouts
int64_t ttime = 0;     // Elapsed time  


// Return acknowledgement that command was received, or the result of the request
void sendAck(const char* val) {
  char response[MAX_RESPONSE];
  int n = snprintf(response, sizeof(response), "(ACK:%s:%s)", target, val);
  if (n <= 0 || n >= (int)sizeof(response)) {
    sendNak(ERROR1);
  }
  else {
    client.println(response);
    ttime = millis();
  }
  if (diag) {
    Serial.print(response);
    Serial.print(" \t");
  }
}


// Return a failure to initiate a command or obtain status of a request
void sendNak(const char* errorMsg) {
  char response[MAX_RESPONSE];
  int n = snprintf(response, sizeof(response), "(NAK:%s:%s)", target, errorMsg);
  if (n <= 0 || n >= (int)sizeof(response)) {
    n = snprintf(response, sizeof(response), "(NAK:%s:%s)", target, ERROR2);
    client.println(response);
    return;
  }
  client.print(response);
  ttime = millis();

  if (diag) {
    Serial.print(" * ");
    Serial.print(response);
    Serial.print(" * \t");
  }
}

/*
 * The standard relay shield uses a HIGH to activate the relays.
 *
 * In contrast a relay module might use a LOW signal.
 * For example:
 * Using a SainSmart 4 channel, 5V relay module. The relay module's JD-VCC jumper 
 * is removed. A separate 5V supply powers the relay module using the GND and 
 * JD-VCC pins where the jumper was removed. The Arduino is powered  separately. 
 * No common ground between the Arduino and the relay module so pull the ground 
 * connector to the relay module. The ground for the input pins is provided back 
 * at the Arduino. The relay output uses the NO and common connectors. The relay 
 * requires a LOW on the signal pin to activate. This is provided when a ON 
 * command is received. Default input is HIGH = inactive relay, open contact.
 *
 * id           Relay pin number
 * activate     HIGH or LOW to activate
 * hold         1 indicates to hold relay closed until a relay OFF is received.
 *              0 indicates a momentary close is wanted
 * value        "ON" or "OFF" Turn relay on or off
 */
void setRelay(int id, int activate, int hold, char* value) {
  int deactivate = LOW;
  if (activate != HIGH)
    deactivate = HIGH;

  if (strcmp(value, "ON") == 0) {
    digitalWrite(id, deactivate);  // NO RELAY would normally already be deactivated
    delay(RELAY_PRIOR_DELAY);
    digitalWrite(id, activate);  // Activate the NO relay (close it)
    if (hold == 0) {
      delay(RELAY_ON_DELAY);
      digitalWrite(id, deactivate);  // Turn NO relay off
    }
  } else {
    digitalWrite(id, deactivate);  // Turn NO relay off
  }
  delay(RELAY_POST_DELAY);
}

/*
 * Get switch value
 * Expect a NO switch configured with a pull up resistor.
 * NO switch: Inactive HIGH input to the pin with pull up resistor, logical 0 input. 
 * When switch closes The LOW voltage logical 1 is applied to the input pin. 
 * The off or on value is to be sent to the host in the ACK response
 */
void getSwitch(int id, char* value) {
  if (digitalRead(id) == OPEN_CONTACT)
    strcpy(value, "OFF");
  else
    strcpy(value, "ON");
}

bool isSwitchOn(int id) {
  char switch_value[16 + 1];
  getSwitch(id, switch_value);
  if (strcmp(switch_value, "ON") == 0) {
    return true;
  }
  return false;
}

// (command:target:value)
bool parseCommand() {
  const char startToken = '(';
  const char endToken = ')';
  char inpBuf[MAX_INPUT + 1] = { 0 };
  int32_t len = 0;
  const uint32_t deadline = millis() + 2000;  // 2s read window
  char* start = 0;
  char* end = 0;

  // Read the input until ')' or timeout
  // Accept any leading noise while finding the initial '('
  strcpy(target, "INPUT");
  for (len = 0; len < MAX_INPUT-1; len++) {
    if ((int32_t)(millis() - deadline) >= 0) {
      sendNak(ERROR13);
      return false;
    }

    int c = client.read();
    if (c < 0) continue;
    inpBuf[len] = (char)c;
    if (inpBuf[len] == startToken) {
      start = inpBuf+len;
    }
    else if (inpBuf[len] == endToken) {
      end = inpBuf+len;
      while (client.available()) {
        client.read();
      }
      break;
    }
  }
  
  inpBuf[len+1] = '\0';
  if (start == 0 || end == 0) {
    sendNak(ERROR13);
    return false;
  }

  if (diag) {
    Serial.print(start);
    Serial.print("\t");
    if (strncmp(start, "(SET", 4) == 0) {
      Serial.print("*");
    }
    if (strlen(start) < 16)
      Serial.print("\t");
  }

  // Remove start and end tokens
  // Obtain separate values for command, target, value
  start++;
  char* cmd = strtok(start, ":");
  char* tgt = strtok(nullptr, ":");
  char* val = strtok(nullptr, ")");

  if (!cmd || !tgt || !val) {
    sendNak(ERROR7);
    return false;
  }
  if (strlen(cmd) >= (size_t)cLen-1 || strlen(tgt) >= (size_t)tLen-1 || strlen(val) >= (size_t)vLen-1) {
    sendNak(ERROR3);
    return false;
  }
  strcpy(command, cmd);
  strcpy(target, tgt);
  strcpy(value, val);
  return true;
}

/*
 * Decode message; dispatch to command or request handlers.
 */
void readInput() {
  if (parseCommand()) {
    int relay = -1;  // -1 = not found, 0 = not implemented, pin number = supported
    int sw = -1;     //      "                 "                    "
    unsigned int activate = HIGH;
    unsigned int hold = 0;
    char diag[MAX_MESSAGE];

    // On initial connection return the version
    if (strcmp(command, "CON") == 0) {
      strcpy(value, version_id);  // Can be seen on host to confirm what is running
      sendAck(value);
      return;
    }

    // Handle command to set relay or perform local breakout functionality
    // SET: OPEN, CLOSE, ABORT, LOCK, AUXSET, ACTn
    else if (strcmp(command, "SET") == 0) {
      command_input = CMD_NONE;
      for (int i = 0; i < cmd_len; i++) {
        if (strcmp(target, relay_info[i].function) == 0) {
          command_input = relay_info[i].cmd;
          if (command_input == CMD_ABORT) {
            if (!isStopAllowed()) {
              sendNak(ERROR10);
              return;
            }
          }
          relay = relay_info[i].relay;
          hold = relay_info[i].hold;
          activate = relay_info[i].activate;
          if (command_input == CMD_OPEN || command_input == CMD_CLOSE) {
            timeMoveMs = millis();
          }
          break;
        }
      }
    }

    // Handle requests to obtain the status of switches
    // GET: OPENED, CLOSED, LOCKED, AUXSTATE ACT1 - ACTn
    else if (strcmp(command, "GET") == 0) {
      for (int i = 0; i < switch_count; i++) {
        if (strcmp(target, switch_info[i].function) == 0) {
          sw = switch_info[i].source;
          break;
        }
      }
    }
  /*
    * See if there was a valid command or request 
    */
    if ((relay == -1) && (sw == -1)) {
      // Unknown input
      int n = snprintf(diag, sizeof(diag), "%s%s", ERROR11, target);
      if (n < 0 || n >= (int)sizeof(diag)) {
        sendNak(ERROR7);
      } else {
        sendNak(diag);
      }
    }

    // Command or Request not implemented
    else if ((relay == 0 || relay == -1) && (sw == 0 || sw == -1)) {
      strcpy(value, "OFF");  // Request Not implemented
      sendAck(value);
    }

    // Valid input received

    // A command was received
    // Set the relay associated with the command and send acknowlege to host
    else if (relay > 0)  // Set Relay response
    {
      commandReceived(relay, activate, hold, value);
    }

    // A get state request was received
    else if (sw > 0)  // Get switch response
    {
      requestReceived(sw);
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
// Abort movement command received, test to see if abort is allowed.
bool isStopAllowed() {
  const uint32_t now = millis();
  const uint32_t elapsedMs = now - timeMoveMs;  // rollover-safe
  timeMoveMs = 0;

  // If the roof is either fully opened or fully closed, ignore the request.
  if (isSwitchOn(SWITCH_OPENED) || isSwitchOn(SWITCH_CLOSED))
    return false;

  if (elapsedMs == 0)
    return false;

  // If time since last open or closed is longer than time allowed refuse
  if (elapsedMs >= (uint32_t)ABORT_MAX_SEC * 1000UL)
    return false;

  // Stop will be attempted
  return true;
}

////////////////////////////////////////////////////////////////////////////////
// Command received

// Here after pin associations resolved and request known
// The default is to set the associated relay to the requested state "ON" or "OFF" and
// send acknowledgement to the host.
// target is the name associated with the relay "OPEN", "CLOSE", "ABORT", "LOCK", "AUXSET".
// It will be used when  sending the acknowledgement to the host. Find out if a particular
// command is being processed using if (strcmp(target, "OPEN") == 0) {do something}
//
// relay: pin id of the relay
// activate HIGH or LOW to activate relay
// hold:  whether relay is to be set permanently =0, or temporarily =1
// value: Set the relay "ON" or "OFF"
//
//
void commandReceived(int relay, int activate, int hold, char* value) {
  // Intervene here
  setRelay(relay, activate, hold, value);
  sendAck(value);  // Send acknowledgement that relay pin associated with "target" was activated to value requested
}

////////////////////////////////////////////////////////////////////////////////

// Here after pin associations resolved and request known
// Request to obtain state of a switch
// The default is to read the associated switch and return result to the host
// target is the name associated with the switch "OPENED", "CLOSED" etc and will
// be used when sending the acknowledgement to the host. Find out if a certain request is being processed using
// if (strcmp(target, "OPENED") == 0) {do something}
//
// sw:     The switch's pin identifier.
// value   getSwitch will read the pin and set this to "ON" or "OFF"
void requestReceived(int sw) {
  // Intervene here if needed
  getSwitch(sw, value);
  sendAck(value);  // Send result of reading pin associated with "target"
}

void initInput(int pin) {
  if (pin > 0 && pin < 100) {
    if (OPEN_CONTACT == HIGH)
      pinMode(pin, INPUT_PULLUP);
    else
      pinMode(pin, INPUT);
  }
}

// Receives what activates the relay and sets the opposite
void initRelay(unsigned int pin, unsigned int activate) {
  if (pin > 0 && pin < 100) {
    pinMode(pin, OUTPUT);
    digitalWrite(pin, (activate == HIGH) ? LOW : HIGH);  // set to inactive level
  }
}

// One time initialization
void setup() {
  // Establish USB port.
  Serial.begin(BAUD_RATE);  // Baud rate to match that in the driver
  
  // Initialize the input sensors/switches
  for (int i = 0; i < switch_count; i++) {
    initInput(switch_info[i].source);
  }

  // Initialize the relays
  for (int i = 1; i < cmd_len; i++) {
    initRelay(relay_info[i].relay, relay_info[i].activate);
  }

  delay(INIT_DELAY_SECS * 1000);  // diagnostic, allow time to get serial monitor displayed

  // check for the WiFi module:
  if (WiFi.status() == WL_NO_MODULE) {
    Serial.println("Unable to contact the board's WiFi component!");
    Serial.println("Try a WiFiS3 example to verify board/library setup.");
    Serial.println("Unable to continue, will require a restart when problem corrected.");
    while (true)
      ;  // Don't continue
  }
  String fv = WiFi.firmwareVersion();  // Check the board's firmware against the installed library
  if (fv < WIFI_FIRMWARE_LATEST_VERSION) {
    Serial.println("Consider upgrading the firmware");
  }
}

void connectWifi() {
  // Connect to the WiFi network:
  WiFi.config(ip);        // WiFi init (static IP)
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print("Connecting to the network ");
    Serial.println(ssid);
    // Connect to WPA/WPA2 network. Change if using open or WEP network:
    WiFi.begin(ssid, pass);
    for (int i = 0; i < 20; i++) {
      delay(1000);
      if (WiFi.status() == WL_CONNECTED)
      {
        return;
      }
    }
  }
}

void printWifiStatus() {
  // print the SSID of the network you're attached to:
  Serial.print("SSID: ");
  Serial.println(WiFi.SSID());
  // print board's IP address:
  IPAddress ip = WiFi.localIP();
  Serial.print("IP Address: ");
  Serial.println(ip);
  // print the received signal strength:
  long rssi = WiFi.RSSI();
  Serial.print("signal strength (RSSI):");
  Serial.print(rssi);
  Serial.println(" dBm");
  Serial.println("");
  Serial.println("Network online.");
}

// Wait here for command or switch request from host
boolean indiConnected = false;  // Driver has connected to local network
void loop() {
 // Connect to the Wifi
  if (WiFi.status() != WL_CONNECTED) {
    connectWifi();          // Wait until connected to WiFi
    server.begin();
    printWifiStatus();
    Serial.println("Ready for driver connections.");
  }

  // Obtain client when INDI driver requests connection
  client = server.available();
  if (client) {
    // Stay wih a single client while it remains connected
    while (client.connected())
    {
      int count = 0;
      // If this is a new driver connection
      if (!indiConnected)
      {
        indiConnected = true;
        Serial.println("New INDI driver connection");
      }
      // When there is input from the client, go process it
      if ((count = client.available()) > 0)
      {
        tstart = millis();
        readInput();
        ttime = millis();
        if (diag) {
          Serial.print(ttime-tstart);
          Serial.print(" ms\t");
          //Serial.print("Input count: ");
          //Serial.println(count);
          Serial.println();
        }
      }
    }
    // Lost driver connection
    client.stop();
    if (indiConnected)  
    {
      indiConnected = false;
      Serial.println("INDI Driver disconnected");      
    }
  }
}
